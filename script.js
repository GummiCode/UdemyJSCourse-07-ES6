/* The course covers the follwoing topics that I'm already familar with:
 1. Let and Const 
    (lecture 4)

 2. The block scope of let and const (compared to function scope of var); let and const defined within {} are not accessible outside of {}.
    (Lecture 5)

 3. Template literals; using ` and ${} to enbed variables and so forth within strings.
    (Lecture 5)

 4. Arrow Functions
    (Lecture 7, 8)

 5. Destructuring.
 (Lecture 9)

 6. Array Methods.
 (Lecture 10)

 7. The Spread operator
 (Lecture 11)
*/

////////////////////////////////////////////////////////////////////////
// L6: Some useful String methods in ES6.
const firstName = "Niel"
const secondName = "Gaiman" 
const name = `${firstName} ${secondName}`;

console.log(name.startsWith("N"));
console.log(name.endsWith("man"));
console.log(name.includes("el Ga"));
console.log(name.repeat(3));
console.log(`${name} `.repeat(3));

//////////////////////////////////////////////////////////////////
// L7-8: Arrow Functions:
//1. One argument, one line: No parentheses, return is implicit.
let giveName = passedName => `${passedName}`;
console.log(giveName(firstName));

//2. Mutiple arguments: Need parentheses.
giveName = (passedName1, passedName2) => `${passedName1} ${passedName2}`;
console.log(giveName(firstName, secondName));

//3. Multiple lines: Need curly parentheses.
let greet = (passedName1, passedName2) => {
  const message = `Hello ${passedName1} ${passedName2}, and welcome to the 2020 literary fair!`;
  console.log(message);
};
greet(firstName, secondName);


//4. .this can be used in arrow functions, and has wider scope than in regular functions. 
/* With regular functions .this has function context. 
However, with arrow functions the context of  .this is wider; .this points to the variable that contains the arrow function.
In the example below, .this is used call values from the object that contains the arrow function. Super useful!
BUT BEWARE! The scope of the arrow function is -one block context down (I think)-. Be sure to use it with the right scope, or you could accidentally reference the global .this (or another .this) rather than the intended .this.
*/

//first example:

const greenBox = {
  color: "green",
  position: 1, 
  clickMe: function () {
    document.querySelector('.green').addEventListener('click', () => {
      const str = `This is the ${this.color} box. Its position is ${this.position}.`;
      alert(str);
    });
  }
}

greenBox.clickMe();

function Person(name) {
  this.name = name;
}

//second example:

pals = ["Sarah", "Jane", "Joel"];

Person.prototype.myPals = function (pals) {
  const palList = pals.map((pal) => 
    `${this.name} is friends with ${pal}`);
  console.log(palList);
}
new Person("Gary").myPals(pals);


///////////////////////////////////////////////////////////////////////////////////////////////////
//L9: Destructuring
//Used to seperate data from an array or an object.

//Array Destructuring //////////////////////////////////////////////////
//Here's an array of starter Pokemon.
const starterPokemon = ["Bulbasaur", "Charmander", "Squirtle", "Pikachu", "Eevee"];
//We can turn the whole array into a set of variables using opne line.
const [grassStarter, fireStarter, waterStarter, electricStarter, normalStarter] = starterPokemon;
console.log(fireStarter);
//We can also use array destructuring to define several variables all at once.
const [applePrice, bananaPrice, pearPrice, peachPrice] = [200, 200, 300, 500];
console.log(bananaPrice);


//Object destructuring //////////////////////////////////////////////
//Here's an object describing Mew.
const mew = {
  name: `Mew`,
  number: 151,
  type1: "psychic",
  type2: null,
  species: `New Species`
};
// We can use destructuring to create variables from the Mew object's properties. 
//NB: the variable names must match the names of the object's parameters.
const {type1, type2} = mew;
console.log(type1);
console.log(type2);
//We can also pull values from an object and give them new variable names.
const {species: mewSpecies} = mew;
console.log(`Mew's species designation: ${mewSpecies} Pokemon`);


//Destructuring Values from Functions////////////////////////////////////
//Used to return multiple values from a function.

// Return the values generated by the function as an array.
const stringifyData = (pokemon) => {
  const nameString = `This pokemon is called ${pokemon.name}!`
  const speciesString = `This is the ${pokemon.species} pokemon!`
  return [nameString, speciesString];
};
//Then use array destructuring syntax to destructure the array returned by the function while calling it.
const[nameString, speciesString] = stringifyData(mew);
console.log(nameString, speciesString);



/////////////////////////////////////////////////////////////////////////////////
//L10: Array Methods
/* Remove this comment to view the effects of the code.

//.from
//The .from method converts a node list into an array.
//In the example below we create a constant that points at the box class elements (ie. the coloured boxes) from the node list generated from the accompanying HTML file.
const boxes = document.querySelectorAll('.box');
//We the nuse .from to create an array of values pointing at these elements.
const boxesArray = Array.from(boxes);
console.log(boxesArray);
//We can now use .forEach to change all of these boxes at once.
boxesArray.forEach(element => element.style.backgroundColor = 'dodgerblue');
//We could refactor this into one line;
//Array.from(boxes).forEach(element => element.style.backgroundColor = 'dodgerblue');


//The .for/of loop
//This is a new 'for' loop method which removes the need to use a set of parameters to process the whole array. Instead of writing 
//        for (let i = 0; i < array.length; i++)
// we can just write
//        for (const element of array)
// for example:
for (const box of boxes) {
  if (box.className === 'box blue') {
    continue;
  } else {
  box.textContent = 'I changed color to blue!'; 
  };
}  

//The benefit of using .for/of instead of .map is that .map doesn't allow for 'break' or 'continue' statements, whereas .for/of does.
*/

//findIndex
//This method lets us find the first value index of values in an array for which a statement returns true.
const numbers = [12, 17, 52, 8, 21, 14, 11];
console.log (numbers.findIndex(element => element >= 20));
//Note that it only gives the inde xof the -first- element in the array that returns true.



////////////////////////////////////////////////////////////////////////////////////////////////////
//L10: The Spread operator 
//The spread operator, '...', converts an array into a comma-separated list of values suitable for insertion into a function.
//The Spread operator is used in the function call.
const addFourValues = (a, b, c, d) => {return (a + b + c + d)};
const ages = [20, 28, 32, 41]
const sumOfAges = addFourValues(...ages);
console.log(sumOfAges);

const pokemonTeam = ["Bulbasaur", "Squirtle", "Charmander", "Pikachu", "Eevee", "Mew"];
const teamSpread = (A, B, C, D, E, F) => {return `${A} will be sent out first. You can switch to ${B}, ${C}, ${D}, ${E} or ${F} during your turn.`}
const starterSpread = teamSpread(...pokemonTeam);
console.log(starterSpread);

//Spread can also be used to join two arrays.
//Additional values can also be inserted.

const iansFolks = ['Diane', 'Maurice'];
const davesFolks = ['Alice', 'Brian'];
const folks = [...iansFolks, "Boris", ...davesFolks];
console.log(folks);

//... can also be used on node lists. Here we combine all h1 elements and box class elements in the DOM into a single array, which we can then loop through to change the text color of these elements.

const h = document.querySelector('h1');
const boxes = document.querySelectorAll('.box');
const all = [h, ...boxes];
Array.from(all).forEach(element => element.style.color = 'orange');



/////////////////////////////////////////////////////////////////////////////////////////
// L12: Rest Parameters
// Used to pass multiple individual values into an array for use in a function.
//The Rest operator is used in the function declaration.
// In the example below, the addTwentyPercent function uses rest parameters to convert the values passed into the function into an array of those values, which can then be processed using array methods such as .map.

addTwentyPercent = (...prices) => {
  return prices.map(price => price += (price/5));
};
console.log(addTwentyPercent(10, 20, 30, 40, 50));

//Rest Parameters can be used in combination with other values:
const birthYears = 
isFullAge = (adultAge, ...years) => {
  years.forEach(age => console.log((2020-age) >= adultAge))
}

isFullAge(18, 1990, 1995, 2000, 2005, 2010, 2015);


//To reiterate:
//The Spread operator is used in the function call.
//The Rest operator is used in the function declaration.


/////////////////////////////////////////////////////////////////////////////////////
// L13: Default Parameters
// Used to give parameters a default value.
 // Simply assign a default value in the function call using '=', as below.
 // Default Parameters must be listed in the function call after all other values, as the default values are inserted if the number of arguments entered < the position of the parameter with a default value.

function smithFamilyMember(firstName, birthYear, eyeColor, lastName = 'Smith') {
  this.firstName = firstName;
  this.lastName = lastName;
  this.birthYear = birthYear;
  this.eyeColor = eyeColor;
};

const john = new smithFamilyMember('John', 1973, 'brown');

console.log(john);