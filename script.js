/* The course covers the follwoing topics that I'm already familar with:
 1. Let and Const 
    (lecture 4)

 2. The block scope of let and const (compared to function scope of var); let and const defined within {} are not accessible outside of {}.
    (Lecture 5)

 3. Template literals; using ` and ${} to enbed variables and so forth within strings.
    (Lecture 5)

 4. Arrow Functions
    (Lecture 7, 8)

 5. Destructuring.
 (Lecture 9)

 6. Array Methods.
 (Lecture 10)
*/

////////////////////////////////////////////////////////////////////////
// L6: Some useful String methods in ES6.
const firstName = "Niel"
const secondName = "Gaiman" 
const name = `${firstName} ${secondName}`;

console.log(name.startsWith("N"));
console.log(name.endsWith("man"));
console.log(name.includes("el Ga"));
console.log(name.repeat(3));
console.log(`${name} `.repeat(3));

//////////////////////////////////////////////////////////////////
// L7-8: Arrow Functions:
//1. One argument, one line: No parentheses, return is implicit.
let giveName = passedName => `${passedName}`;
console.log(giveName(firstName));

//2. Mutiple arguments: Need parentheses.
giveName = (passedName1, passedName2) => `${passedName1} ${passedName2}`;
console.log(giveName(firstName, secondName));

//3. Multiple lines: Need curly parentheses.
let greet = (passedName1, passedName2) => {
  const message = `Hello ${passedName1} ${passedName2}, and welcome to the 2020 literary fair!`;
  console.log(message);
};
greet(firstName, secondName);


//4. .this can be used in arrow functions, and has wider scope than in regular functions. 
/* With regular functions .this has function context. 
However, with arrow functions the context of  .this is wider; .this points to the variable that contains the arrow function.
In the example below, .this is used call values from the object that contains the arrow function. Super useful!
BUT BEWARE! The scope of the arrow function is -one block context down (I think)-. Be sure to use it with the right scope, or you could accidentally reference the global .this (or another .this) rather than the intended .this.
*/

//first example:

const greenBox = {
  color: "green",
  position: 1, 
  clickMe: function () {
    document.querySelector('.green').addEventListener('click', () => {
      const str = `This is the ${this.color} box. Its position is ${this.position}.`;
      alert(str);
    });
  }
}

greenBox.clickMe();

function Person(name) {
  this.name = name;
}

//second example:

pals = ["Sarah", "Jane", "Joel"];

Person.prototype.myPals = function (pals) {
  const palList = pals.map((pal) => 
    `${this.name} is friends with ${pal}`);
  console.log(palList);
}
new Person("Gary").myPals(pals);


///////////////////////////////////////////////////////////////////////////////////////////////////
//L9: Destructuring
//Used to seperate data from an array or an object.

//Array Destructuring //////////////////////////////////////////////////
//Here's an array of starter Pokemon.
const starterPokemon = ["Bulbasaur", "Charmander", "Squirtle", "Pikachu", "Eevee"];
//We can turn the whole array into a set of variables using opne line.
const [grassStarter, fireStarter, waterStarter, electricStarter, normalStarter] = starterPokemon;
console.log(fireStarter);
//We can also use array destructuring to define several variables all at once.
const [applePrice, bananaPrice, pearPrice, peachPrice] = [200, 200, 300, 500];
console.log(bananaPrice);


//Object destructuring //////////////////////////////////////////////
//Here's an object describing Mew.
const mew = {
  name: `Mew`,
  number: 151,
  type1: "psychic",
  type2: null,
  species: `New Species`
};
// We can use destructuring to create variables from the Mew object's properties. 
//NB: the variable names must match the names of the object's parameters.
const {type1, type2} = mew;
console.log(type1);
console.log(type2);
//We can also pull values from an object and give them new variable names.
const {species: mewSpecies} = mew;
console.log(`Mew's species designation: ${mewSpecies} Pokemon`);


//Destructuring Values from Functions////////////////////////////////////
//Used to return multiple values from a function.

// Return the values generated by the function as an array.
const stringifyData = (pokemon) => {
  const nameString = `This pokemon is called ${pokemon.name}!`
  const speciesString = `This is the ${pokemon.species} pokemon!`
  return [nameString, speciesString];
};
//Then use array destructuring syntax to destructure the array returned by the function while calling it.
const[nameString, speciesString] = stringifyData(mew);
console.log(nameString, speciesString);



/////////////////////////////////////////////////////////////////////////////////
//L10: Array Methods
// Remove this comment to view the effects of the code.

//.from
//The .from method converts a node list into an array.
//In the example below we create a constant that points at the box class elements (ie. the coloured boxes) from the node list generated from the accompanying HTML file.
const boxes = document.querySelectorAll('.box');
//We the nuse .from to create an array of values pointing at these elements.
const boxesArray = Array.from(boxes);
console.log(boxesArray);
//We can now use .forEach to change all of these boxes at once.
boxesArray.forEach(element => element.style.backgroundColor = 'dodgerblue');
//We could refactor this into one line;
//Array.from(boxes).forEach(element => element.style.backgroundColor = 'dodgerblue');


//The .for/of loop
//This is a new 'for' loop method which removes the need to use a set of parameters to process the whole array. Instead of writing 
//        for (let i = 0; i < array.length; i++)
// we can just write
//        for (const element of array)
// for example:
for (const box of boxes) {
  if (box.className === 'box blue') {
    continue;
  } else {
  box.textContent = 'I changed color to blue!'; 
  };
}  

//The benefit of using .for/of instead of .map is that .map doesn't allow for 'break' or 'continue' statements, whereas .for/of does.

//findIndex
//This method lets us find the first value index of values in an array for which a statement returns true.
const numbers = [12, 17, 52, 8, 21, 14, 11];
console.log (numbers.findIndex(element => element >= 20));
//Note that it only gives the inde xof the -first- element in the array that returns true.





