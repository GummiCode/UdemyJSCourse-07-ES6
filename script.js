/* The course covers the follwoing topics that I'm already familar with:
 1. Let and Const 
    (lecture 4)

 2. The block scope of let and const (compared to function scope of var); let and const defined within {} are not accessible outside of {}.
    (Lecture 5)

 3. Template literals; using ` and ${} to enbed variables and so forth within strings.
    (Lecture 5)

 4. Arrow Functions
    (Lecture 7, 8)

 5. Destructuring.
 (Lecture 9)

 6. Array Methods.
 (Lecture 10)

 7. The Spread operator
 (Lecture 11)

 8. Rest Parameters
 (Lecture 12)

 9. Default Parameters in Constructors
 (Lecture 13)

 10. Maps
 (Lecture 14)
 */ 

////////////////////////////////////////////////////////////////////////
// L6: Some useful String methods in ES6.
const firstName = "Niel"
const secondName = "Gaiman" 
const name = `${firstName} ${secondName}`;

console.log(name.startsWith("N"));
console.log(name.endsWith("man"));
console.log(name.includes("el Ga"));
console.log(name.repeat(3));
console.log(`${name} `.repeat(3));

//////////////////////////////////////////////////////////////////
// L7-8: Arrow Functions:
//1. One argument, one line: No parentheses, return is implicit.
let giveName = passedName => `${passedName}`;
console.log(giveName(firstName));

//2. Mutiple arguments: Need parentheses.
giveName = (passedName1, passedName2) => `${passedName1} ${passedName2}`;
console.log(giveName(firstName, secondName));

//3. Multiple lines: Need curly parentheses.
let greet = (passedName1, passedName2) => {
  const message = `Hello ${passedName1} ${passedName2}, and welcome to the 2020 literary fair!`;
  console.log(message);
};
greet(firstName, secondName);


//4. .this can be used in arrow functions, and has wider scope than in regular functions. 
/* With regular functions .this has function context. 
However, with arrow functions the context of  .this is wider; .this points to the variable that contains the arrow function.
In the example below, .this is used call values from the object that contains the arrow function. Super useful!
BUT BEWARE! The scope of the arrow function is -one block context down (I think)-. Be sure to use it with the right scope, or you could accidentally reference the global .this (or another .this) rather than the intended .this.
*/

//first example:

const greenBox = {
  color: "green",
  position: 1, 
  clickMe: function () {
    document.querySelector('.green').addEventListener('click', () => {
      const str = `This is the ${this.color} box. Its position is ${this.position}.`;
      alert(str);
    });
  }
}

greenBox.clickMe();

function Person(name) {
  this.name = name;
}

//second example:

pals = ["Sarah", "Jane", "Joel"];

Person.prototype.myPals = function (pals) {
  const palList = pals.map((pal) => 
    `${this.name} is friends with ${pal}`);
  console.log(palList);
}
new Person("Gary").myPals(pals);


///////////////////////////////////////////////////////////////////////////////////////////////////
//L9: Destructuring
//Used to seperate data from an array or an object.

//Array Destructuring //////////////////////////////////////////////////
//Here's an array of starter Pokemon.
const starterPokemon = ["Bulbasaur", "Charmander", "Squirtle", "Pikachu", "Eevee"];
//We can turn the whole array into a set of variables using opne line.
const [grassStarter, fireStarter, waterStarter, electricStarter, normalStarter] = starterPokemon;
console.log(fireStarter);
//We can also use array destructuring to define several variables all at once.
const [applePrice, bananaPrice, pearPrice, peachPrice] = [200, 200, 300, 500];
console.log(bananaPrice);


//Object destructuring //////////////////////////////////////////////
//Here's an object describing Mew.
const mew = {
  name: `Mew`,
  number: 151,
  type1: "psychic",
  type2: null,
  species: `New Species`
};
// We can use destructuring to create variables from the Mew object's properties. 
//NB: the variable names must match the names of the object's parameters.
const {type1, type2} = mew;
console.log(type1);
console.log(type2);
//We can also pull values from an object and give them new variable names.
const {species: mewSpecies} = mew;
console.log(`Mew's species designation: ${mewSpecies} Pokemon`);


//Destructuring Values from Functions////////////////////////////////////
//Used to return multiple values from a function.

// Return the values generated by the function as an array.
const stringifyData = (pokemon) => {
  const nameString = `This pokemon is called ${pokemon.name}!`
  const speciesString = `This is the ${pokemon.species} pokemon!`
  return [nameString, speciesString];
};
//Then use array destructuring syntax to destructure the array returned by the function while calling it.
const[nameString, speciesString] = stringifyData(mew);
console.log(nameString, speciesString);



/////////////////////////////////////////////////////////////////////////////////
//L10: Array Methods
/* Remove this comment to view the effects of the code.

//.from
//The .from method converts a node list into an array.
//In the example below we create a constant that points at the box class elements (ie. the coloured boxes) from the node list generated from the accompanying HTML file.
const boxes = document.querySelectorAll('.box');
//We the nuse .from to create an array of values pointing at these elements.
const boxesArray = Array.from(boxes);
console.log(boxesArray);
//We can now use .forEach to change all of these boxes at once.
boxesArray.forEach(element => element.style.backgroundColor = 'dodgerblue');
//We could refactor this into one line;
//Array.from(boxes).forEach(element => element.style.backgroundColor = 'dodgerblue');


//The .for/of loop
//This is a new 'for' loop method which removes the need to use a set of parameters to process the whole array. Instead of writing 
//        for (let i = 0; i < array.length; i++)
// we can just write
//        for (const element of array)
// for example:
for (const box of boxes) {
  if (box.className === 'box blue') {
    continue;
  } else {
  box.textContent = 'I changed color to blue!'; 
  };
}  

//The benefit of using .for/of instead of .map is that .map doesn't allow for 'break' or 'continue' statements, whereas .for/of does.
*/

//findIndex
//This method lets us find the first value index of values in an array for which a statement returns true.
const numbers = [12, 17, 52, 8, 21, 14, 11];
console.log (numbers.findIndex(element => element >= 20));
//Note that it only gives the inde xof the -first- element in the array that returns true.



////////////////////////////////////////////////////////////////////////////////////////////////////
//L10: The Spread operator 
//The spread operator, '...', converts an array into a comma-separated list of values suitable for insertion into a function.
//The Spread operator is used in the function call.
const addFourValues = (a, b, c, d) => {return (a + b + c + d)};
const ages = [20, 28, 32, 41]
const sumOfAges = addFourValues(...ages);
console.log(sumOfAges);

const pokemonTeam = ["Bulbasaur", "Squirtle", "Charmander", "Pikachu", "Eevee", "Mew"];
const teamSpread = (A, B, C, D, E, F) => {return `${A} will be sent out first. You can switch to ${B}, ${C}, ${D}, ${E} or ${F} during your turn.`}
const starterSpread = teamSpread(...pokemonTeam);
console.log(starterSpread);

//Spread can also be used to join two arrays.
//Additional values can also be inserted.

const iansFolks = ['Diane', 'Maurice'];
const davesFolks = ['Alice', 'Brian'];
const folks = [...iansFolks, "Boris", ...davesFolks];
console.log(folks);

//... can also be used on node lists. Here we combine all h1 elements and box class elements in the DOM into a single array, which we can then loop through to change the text color of these elements.

const h = document.querySelector('h1');
const boxes = document.querySelectorAll('.box');
const all = [h, ...boxes];
Array.from(all).forEach(element => element.style.color = 'orange');



/////////////////////////////////////////////////////////////////////////////////////////
// L12: Rest Parameters
// Used to pass multiple individual values into an array for use in a function.
//The Rest operator is used in the function declaration.
// In the example below, the addTwentyPercent function uses rest parameters to convert the values passed into the function into an array of those values, which can then be processed using array methods such as .map.

addTwentyPercent = (...prices) => {
  return prices.map(price => price += (price/5));
};
console.log(addTwentyPercent(10, 20, 30, 40, 50));

//Rest Parameters can be used in combination with other values:
const birthYears = 
isFullAge = (adultAge, ...years) => {
  years.forEach(age => console.log((2020-age) >= adultAge))
}

isFullAge(18, 1990, 1995, 2000, 2005, 2010, 2015);


//To reiterate:
//The Spread operator is used in the function call.
//The Rest operator is used in the function declaration.


/////////////////////////////////////////////////////////////////////////////////////
// L13: Default Parameters
// Used to give parameters a default value.
 // Simply assign a default value in the function call using '=', as below.
 // Default Parameters must be listed in the function call after all other values, as the default values are inserted if the number of arguments entered < the position of the parameter with a default value.

function smithFamilyMember(firstName, birthYear, eyeColor, lastName = 'Smith') {
  this.firstName = firstName;
  this.lastName = lastName;
  this.birthYear = birthYear;
  this.eyeColor = eyeColor;
};

const john = new smithFamilyMember('John', 1973, 'brown');

console.log(john);


////////////////////////////////////////////////////////////////////////////////////////
// L14: Maps
// A Map is a new key-value data structure.
// Used to map string keys to arbitrary values.
// The key difference between a map and an object is that in objects, keys must be strings,
// whereas in maps we can use any kind of primitive value (strings, numbers, booleans) and functions and objects as keys.
// This has numerous powerful uses.
//  Maps also have some special methods.


//Create the map using the following syntax:
const question = new Map();

// Assign properties (key-value pairs) using the following syntax:
question.set("question", "What was the title of Huey Lewis And The News' 1983 hit album?")
question.set(1, "Sports");
question.set(2, "Games");
question.set(3, "Activities");
question.set(4, "Hobbies");
question.set(5, "Things to Make and Do");
question.set("correct", 1);
question.set(true, "Correct Answer!");
question.set(false, "Wrong. Please try again.")

console.log(question);

//We get values from the Map using the .get method.
console.log(question.get("question"));

//We can check the map size using the .size method.
console.log(question.size);

//We can remove properties from the map using the .delete method with the key of the property you want to remove.
question.delete(5);
console.log(question);

// The .has method can be used as a conditional operator. It returns true if a property exists which has a key equal to the value assigned to the .has method.
if(question.has(4)) {question.delete(4)};
console.log(question);

// .forEach() can be used on maps. It iterates over each property in the map, and the key and value can both be passed in.
// Pretty powerful, not least because you can pass in functions used as keys or values.
question.forEach((value, key) => console.log(`This is "${key}", and it's set to "${value}".`));

// for/of loops can also be used on Maps.
// We use the .entries method to point the for/of loop at every entry in the questions map sequentially.
// We also use destructuring (see above) to tell the for.of loop to point at both the key and the value of each property and store them as separate variables. 
// These 'key' and 'value' variables are then used in the function embedded in the for/of loop.
for(let [key, value] of question.entries()) {
  console.log(`This is "${key}", and it's set to "${value}".`)
};

// As we can use various data types as keys in Maps, we can use this as a selection criteria.
// Below we log the values assigned to keys that are numbers.
for (let [key, value] of question.entries()) {
  if (typeof(key) === 'number') {
    console.log(`Answer ${key}: ${value}`)
  }
};

//In the lines below we create a prompt requesting an answer as an integer. 
//The number is compared to the value of the 'answer' property (1).
//As the map includes properties with keys of 'true' for the correct answer message and 'false' for the wrong answer message, we can plug the result of this equality check straight into another .get to call the appropriate response message into the console. This is the beauty of maps!
const ans = parseInt(prompt('Write the correct answer'));
console.log (question.get (ans === question.get('correct')));

//the .clear method deletes all values from the map.
/*
question.clear();
question.set("Status", "This Map is (almost) empty.");
console.log(question);
*/


///////////////////////////////////////////////////////////////////////////////////////////////////
// L15. Classes
//Syntactic sugar for function constructors. Called Class Declarations.

class Individual {
  constructor(name, birthYear, job) {
    this.name = name;
    this.birthYear = birthYear;
    this.job = job;
  }

  calculateAge() {
    const age = new Date().getFullYear - this.birthYear;
    console.log(age);
  }

  static greeting () {
    console.log("Hi!");
  }

};

const adam = new Individual("Adam", 1983, "Carpenter");
console.log(adam);

// Static Methods are methods included in the class constructor, but not inherited by instances of that class.
// One is included above, defined usin g the keyword 'static'.
// I presume these can be used to construct the class instances (eg. by procssing data to include in the class instance)e without being included in the class, or it could be used to invoke a function when the class is invoked without passing on that function? You could definitely use a static method to include a numerical incrementor (eg. add 1 to the value of a variable within the constructor). Useful for assigning unique IDs.
// they can be called using the class constructor's id.

Individual.greeting();


///////////////////////////////////////////////////////////////////////////////////
// L16. Subclasses: Class Inheritance

// We can use the "extends" keyword to create a subclass from an existing class.
// The "super" keyword is used to inform the subclass that certain variables are assigned in the same manner as in the superclass.
// The subclass can include anything a class can (because it is a class).

class Athlete extends Individual {
  constructor(name, birthYear, job, athleteType, league, representing) {
    super(name, birthYear, job);
    this.athleteType = athleteType;
    this.league = league;
    this.representing = representing;
  }

  stateStatus () {
    console.log(`${this.name} is a professional ${this.athleteType} representing ${this.representing} in the ${this.league} League.`);
  }
}

const athleteAdam = new Athlete("Adam", "1983", "Athlete", "Tightrope Walker", "S", "Areppa");

athleteAdam.stateStatus();